var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Overview","text":"<p>This is a set of notes on how I'm building my custom ERCF (Enraged Rabbit Carrot Feeder). In many ways this custom build is likely to be similar to what the (as yet to be released) ERCF v2 will be.</p> <p>Figuring out how to make this custom build can be a bit daunting since there are so many different pieces to it. Thankfully I did not have to figure this all out on my own. I was able to search the internet and come across various resources and posts from some awesome people. I think what I've come up with (so far) is pretty good, so I thought I'd take notes and also share them with others (as well as future me who forgets things).</p> <p>Please check out the sidebar on the left (pull it down if you have to in case it is collapsed) and browse the various sections I've compiled thus far.</p> <p>Note: This isn't meant to be a build guide, although it should contain enough information to help with most builds. Instead it is a collection of notes and information that I collected while building my ERCF, using a FYSETC kit and a selection of mods that I thought made sense. So please be mindful that there can be some mistakes or inefficiencies in how I built mine. Also some of what I've done might not apply to your own build especially when different parts or mods are used.</p> <p>Oh...and thanks for visiting.</p> <p>--Sakitume (Sock it to me)</p> <p>My ERCF Build Log. To check out my build log you may need this invite to the Delayed Development discord server</p> <p>My YouTube channel</p>"},{"location":"assembly/filament-blocks.html","title":"Filament Blocks","text":"<p>TODO</p>"},{"location":"assembly/gearbox.html","title":"Gearbox","text":""},{"location":"assembly/gearbox.html#important","title":"Important","text":""},{"location":"assembly/gearbox.html#wires-for-the-gearbox","title":"Wires for the gearbox","text":"<p>During assembly of the gearbox there will be a point where you must be mindful about the endstop wires and gear motor wires. You want to make sure they are routed between the \"Gear Box Front\" and \"Gear Box Back\" parts when those parts are being mounted onto the 2020 extrusion. If you don't do this correctly you will likely find that you cannot install the bottom plate and will have to disaasemble and redo this area. I learned the hard way, hopefully you can avoid this.</p> <p>I need to put some pictures up about this here!!! In the meantime you can refer to my gearbox assembly video at at time 22:50.</p>"},{"location":"assembly/gearbox.html#extra-heatset-inserts","title":"Extra heatset inserts","text":"<p>I made a mistake when I assembled my gearbox because I didn't install two additional heatset inserts. Those inserts retain two screws that act as pins for a \"Latch\" part. I describe this in more detail below.</p>"},{"location":"assembly/gearbox.html#heatset-inserts","title":"Heatset Inserts","text":"<p>You should consult the original ERCF Build Manual. It helps you figure out where heatset inserts should be used. Even though we are using SturdyBunny the ERCF manual is still pretty close.</p> <p>One big difference that I came across (or got bitten by) is that the gear box parts use inserts differently between SturdyBunny versus ERCF. With ERCF the \"Gear Box Back\" part uses 4 inserts. With SturdyBunny the \"Gear Box Back\" part requires 6, or so I now believe. I missed this because I reviewed the SturdyBunny CAD file to check for inserts and only counted 4, but after assembling the gearbox I believe it should be using two additional inserts to prevent the two screws that act as pins for a latch from backing out.</p>"},{"location":"assembly/gearbox.html#ercf-gear-box-back-instructions-that-show-heatset-inserts","title":"ERCF \"Gear Box BacK\" instructions that show heatset inserts","text":"<p>For ERCF the build manual (page 22) shows only four heatset inserts are used for the \"Gear Box Back\" part. </p>"},{"location":"assembly/gearbox.html#sturdybunny-gear-box-back-cad-drawings-that-show-heatset-inserts","title":"SturdyBunny \"Gear Box Back\" CAD drawings that show heatset inserts","text":"<p>The <code>Gear_Box_Back_v2</code> part viewed from the back. Notice you can see three inserts are needed from this view </p> <p>The <code>Gear_Box_Back_v2</code> part viewed from the back and tilted back so you can see the bottom. Notice bottom has one insert. </p> <p>The <code>Gear_Box_Back_v2</code> part viewed from the front. The insert at the top was already mentioned, but the two holes being called out do not have inserts....but I think they should. This would solve the issue of those screws backing out accidentally. </p> <p>IMPORTANT: When building the gearbox, please see if you can add those two additional inserts into the holes shown above</p>"},{"location":"assembly/gearbox.html#another-video","title":"Another Video","text":"<p>I was able to make some time to cut the raw footage I took while assembling the gearbox and push out another video to YouTube </p> <p>Note: The mistake I made with the two screws that act as pins for one of the latches is described at 14:09 in the video. I have not updated the video to describe where the missed heatset inserts should have been placed. Hopefully the notes and pictures I have placed in this guide will help explain what should have been done</p>"},{"location":"assembly/prep.html","title":"Prep","text":"<p>You will want to reference the original ERCF v1.1 Build Manual</p> <p>I have lots of pictures and raw video footage of when I assembled my ERCF. I hope to make some time to edit something  together and post up to YouTube. </p> <p>I'll throw up some basic stuff for now</p>"},{"location":"assembly/prep.html#2020-extrusion","title":"2020 extrusion","text":"<p>SturdyBunny requires a length of 2020 extrusion. The exact length depends on the number of gates you want as well as the type of filament blocks you'll be using (Triple-Decky or Thumper Blocks).</p>"},{"location":"assembly/prep.html#if-using-thumper-blocks","title":"If using Thumper Blocks","text":"<p>I have a 6 gate ERCF kit. I cut my extrusion to 175mm. This allows me to fully swing open the upper part of the assembly to about 105 degrees. So....a formula could be derived like this:</p> <pre><code>(NumberOfGates * 21) + 49\n</code></pre> <p>A 9 gate build would probably be around 238mm; I'd round that up to an even 240mm. This is just an estimation</p>"},{"location":"assembly/prep.html#if-using-triple-decky","title":"If using Triple-Decky","text":"<p>If using Triple-Decky then reference this post from the designer of Triple-Decky.</p> <p>It basically says this about the extrusion:</p> <pre><code>Length of 2020 extrusion = 54.6 + (N x 23.05) Note that the extrusion can go past the block end without problem.\n</code></pre> <p>I've also heard several times on the Voron discord server that 7 1/4\" (184mm) is a good length for a 6 gate build See this post on the Voron discord server</p>"},{"location":"assembly/prep.html#heatset-inserts","title":"Heatset inserts","text":"<p>Reference the manual, you'll need to be able to install heatset inserts into a variety of different parts. The manual provides a link to a tutorial in case you aren't already familiar with this process</p>"},{"location":"assembly/selector.html","title":"Selector","text":""},{"location":"assembly/selector.html#springy","title":"Springy","text":"<p>TODO</p>"},{"location":"assembly/selector.html#servo-arm","title":"Servo arm","text":"<p>You will need to wait until you have Happy Hare installed before you can install the servo arm. This is because you want to set the servo into position (either up or down) so you can align the arm to match that position.</p>"},{"location":"sidebar/ERCF-filament-cutter.html","title":"ERCF Filament Cutter","text":"<p>TODO</p> <pre><code>CUTTER_OPEN\nCUTTER_CLOSE\n</code></pre> <pre><code>SET_SERVO SERVO=cut_servo  ANGLE=0\n</code></pre> <pre><code>SET_SERVO SERVO=cut_servo  ANGLE=5\n</code></pre>"},{"location":"sidebar/align-servo.html","title":"Servo Arm","text":"<p>Again, some quick notes for now. TODO polish this</p> <p>You cannot install and align the servo arm until you've assembled most of your ERCF as well as installed Happy Hare. This is because the servo has splines that the servo arm aligns to. You want to make sure the servo arm is in a known position (either Up or Down) before you attache the servo arm to the servo and tighten it down.</p> <p>Reference the Happy Hare section of this document and have a basic install of Happy Hare running before continuing with the rest of this section.</p>"},{"location":"sidebar/align-servo.html#aligning-the-servo-arm","title":"Aligning the servo arm","text":"<p>After you've established that you can issue <code>MMU</code> commands (via the console) to control the ERCF you can use the following command to set the servo to the <code>UP</code> position:</p> <pre><code>MMU_SERVO POS=up\n</code></pre> <p>Toggle between up and down positions (ending in up) a few times to make sure servo is working and alleviate any backlash in the gearing:</p> <pre><code>MMU_SERVO POS=down\nMMU_SERVO POS=up\nMMU_SERVO POS=down\nMMU_SERVO POS=up\n</code></pre> <p>Place the servo arm into position so that it looks similar to what you see in the following pictures.</p> <p>Servo arm in UP position as viewed from back (showing the stopper portion of the arm) </p> <p>From the backside notice how the stopper portion of the arm is just about touching the body of the servo, but with a slight gap. This may differ by a tiny amount (compared to my pics) because each servo is different and the splines might line up just a tad bit different than mine has. If it doesn't seem right you can retry and adjust by one spline tooth to see if that looks better.</p> <p>Once you're happy with the position of the arm snug it down with the screw. The Happy Hare default values for <code>UP</code> and <code>DOWN</code> position are pretty good but I strongly suggest you test it out and fine tune it. At the very least make sure the values aren't too high or low so that the servo doesn't try to go beyond the range that its physical stopper allows it. Since you've installed the servo arm while the servo was in the <code>UP</code> position hopefully you'll only need to fine tune the <code>DOWN</code> position (if needed).</p> <p>Issue the following command to see how the arm looks when in the <code>DOWN</code> position</p> <pre><code>MMU_SERVO POS=down\n</code></pre> <p>Try toggling back and forth between the two positions to make sure you're happy with everything. If the servo is trying to go a little too far past its physical limits you can adjust the servo angles used for <code>UP</code> and <code>DOWN</code>. I describe how to do that in the following section.</p>"},{"location":"sidebar/align-servo.html#fine-tuning-the-servo-arm-angles","title":"Fine tuning the servo arm angles","text":"<p>You should first make sure your <code>DOWN</code> angle isn't too high that the servo arm bumpstop (portion of the servo arm) isn't colliding with the body of the servo. This will be your maximum angle to use when fine tuning. The default that Happy Hare set for you might be perfectly fine, but it is best to check for yourself.</p> <p>Servo arm in DOWN position as viewed from back (showing the stopper portion of the arm) </p> <p>After that you should fine tune the <code>DOWN</code> angle so that the servo arm achieves an ideal position against the tophats of your filament blocks. What that angle is depends on which filament block tophat you have (Triple-Decky vs Thumper Blocks) and also your servo choice. I can provide you some general guidelines based on my own experience.</p> <p>If you're using Springy, back off on the tensioner screw all the way. Swing up the upper part of the ERCF so you can easily view the servo. Back off that screw while applying slight pressure to the servo and watch and feel until you know it has reached its upper limit of travel. </p> <p>Note: You can leave it like this for now (and tighten down the tensioner screw as needed when you check for filament slippage. Or you can preload the spring by turning it just a bit so that you can see the servo has moved down just a little bit.</p> <p>You can then swing back this upper assembly and latch it into place and select a gate that you want to work with, in the following example I use the 3rd gate, gate 2.</p> <pre><code>MMU_SELECT TOOL=2\n</code></pre> <p>Place a short length of filament so it exits the ERCF by a small amount. Next issue the following command to engage the servo so that the BMG gears clamp down on the filament.</p> <pre><code>MMU_SERVO POS=down\n</code></pre> <p>Grab one end of the filament with one hand, and with the other hand hold onto the knob at the end of the D-Shaft so that it doesn't turn. Tug on the filament and see if the filament slips between the gears. You can either adjust the angle to try and get more leverage, and/or you can adjust the Springy tensioner screw.</p>"},{"location":"sidebar/align-servo.html#how-to-set-the-servo-angle","title":"How to set the servo angle","text":"<p>To adjust the servo angle you'll need to figure out how to set a specific numeric value for it. Examine your <code>mmu_parameters.cfg</code> file and look for a section that looks like this:</p> <pre><code># Servo configuration  -----------------------------------------------------------------------------------------------------\n#\n# Angle of the servo in three named positions:\n#   up   = tool is selected and filament is allowed to freely move through gate\n#   down = to grip filament\n#   move = ready the servo for selector move (optional - defaults to up)\n#\n# Note that leaving the servo active when down can stress the electronics and is not recommended with EASY-BRD or ERB board\n# unless the 5v power supply has been improved and it is not necessary with standard ERCF build.\n# Make sure your hardware is suitable for the job!\n#\nservo_up_angle: 30              # Default: MG90S servo: Up=30    ; SAVOX SH0255MG: Up=140\nservo_down_angle: 140           # Default: MG90S servo: Down=140 ; SAVOX SH0255MG: Down=30\nservo_move_angle: 30            # Optional angle used when selector is moved (defaults to up position)\n</code></pre> <p>The <code>servo_down_angle</code> is set to 140. That means when the <code>MMU_SERVO POS=down</code> command is executed, the angle of the servo arm is set to 140. If that is too much, or too little you the following command provide different values for the <code>ANGLE</code> parameter. The example below sets the servo angle to 130.</p> <pre><code>SET_SERVO SERVO=mmu_servo  ANGLE=130\n</code></pre> <p>Note: You could also use the equivalent (but shorter) <code>MMU_SERVO ANGLE=130</code></p> <p>So the process I used to set the angle was to issue <code>MMU_SERVO POS=down</code> (after selecting a gate of course), then by visually inspecting and/or testing for filament slip I could use <code>SET_SERVO SERVO=mmu_servo  ANGLE=XXX</code> (where <code>XXX</code> is a guess of what I think might work better) to test an angle. Once I found a value that I liked I then edited the value of <code>servo_down_angle</code> in the <code>mmu_parameters.cfg</code> file.</p> <p>You'll try to get what you think is a good feel or compromise. What the exact angle and/or Springy tensioner adjustment you should have is something you'll need to judge for yourself and will likely want to fine tune even further once you have your ERCF up and running and you work out issues that come up.</p>"},{"location":"sidebar/align-servo.html#my-final-angles","title":"My final angles","text":"<p>Here's what I ended up putting into my <code>mmu_parameters.cfg</code> file. What you end up will almost assuredly be be different.</p> <pre><code># Servo configuration  -----------------------------------------------------------------------------------------------------\n#\n# Angle of the servo in three named positions:\n#   up   = tool is selected and filament is allowed to freely move through gate\n#   down = to grip filament\n#   move = ready the servo for selector move (optional - defaults to up)\n#\n# Note that leaving the servo active when down can stress the electronics and is not recommended with EASY-BRD or ERB board\n# unless the 5v power supply has been improved and it is not necessary with standard ERCF build.\n# Make sure your hardware is suitable for the job!\n#\n#servo_up_angle: 30            # Default: MG90S servo: Up=30    ; SAVOX SH0255MG: Up=140\n#servo_down_angle: 140            # Default: MG90S servo: Down=140 ; SAVOX SH0255MG: Down=30\n#servo_move_angle: 30            # Optional angle used when selector is moved (defaults to up position)\n\n# These values are ones I checked using: SET_SERVO SERVO=mmu_servo ANGLE=50\n# and work best with my MG90S servo, servo arm and Thumper Blocks configuration\nservo_up_angle: 50\nservo_down_angle: 135\nservo_move_angle: 50\n</code></pre> <p>I commented out the original values so I could easily refer to them if I ever needed to. I set the <code>servo_move_angle</code> to be the same as my <code>servo_up_angle</code>.</p>"},{"location":"sidebar/custom-build-description.html","title":"What is this custom build?","text":"<p>I based this build on (what I call) a \"recipe\" provided by Tea (a member of the Voron discord server) who made a post in the <code>#ercf_questions</code> channel around May 2023 on what she would use if she were to make an ERCF in May 2023</p> <p>Note: If you need an invite to reach that Voron discord server post you can try this</p>"},{"location":"sidebar/custom-build-description.html#the-basic-recipe","title":"The basic recipe","text":"<p>The original recipe as described by Tea uses the following ingredients:</p> <ul> <li>SturdyBunny - A fork of the original ERCF project. So instead of the original ERCF project, we start with this.<ul> <li>SturdyBunny uses a small length of 2020 extrusion in place of the two 8mm threaded rod of the original ERCF design making this more...uh....sturdy</li> </ul> </li> <li>Springy - A modified selector (the carriage that slides back and forth selecting one port/gate over another)</li> <li>Triple-Decky - These are improved filament blocks that are very popular and well established</li> <li>Binky - This is an improved encoder, the subsystem that helps figure out how much filament is being pushed/pulled</li> </ul> <p>That's the \"recipe\" that Tea describes and what many people consider to be the \"Community ERCF v2\". It's a fine recipe, however I'm changing things up a little bit with my custom build.</p> <p>Rather than using Triple-Decky I've opted to use Thumper Blocks. And to avoid tip tuning (which I hear is a time consuming and tricky process), I've opted to use a filament cutter. And I'm going to try out the ERCF Filament Cutter</p> <p>More info on these different mods can be found here</p>"},{"location":"sidebar/custom-build-description.html#thats-a-lot-of-ingredients","title":"That's a lot of ingredients","text":"<p>Yeah...to build this custom beast you are going to have to jump around a bunch of different mods/designs. Each one will have a set of <code>.stl</code> files that you need to print. And it isn't very clear which files you actually need and which ones you should skip altogether. Then you have to assemble everything and there isn't going to be an instruction manual for this. </p> <p>But don't worry, while it may seem daunting there are others who have traveled this path (or one similar to it) and that makes it easier. There are several resources available that you can turn to:</p> <ul> <li>The <code>#ercf_questions</code> channel on the Voron Discord Server has a lot of activity with people posting questions (and often answers) regarding ERCF. To be honest, because it can be a bit busy at times, and due to how Discord works, some posts can get lost (scroll away) due to the activity.</li> <li>Matt's Unofficial ERCF v2 Printed Parts Tracker spreadsheet</li> <li>The <code>#ercf_mmu</code> channel on fizzy's 3DPrinting Discord server has some helpful folks. Not as busy as the Voron Discord server, but maybe that's a good thing.</li> <li>My ERCF Build Log on the Delayed Development discord server (invite for this server is here)</li> </ul> <p>And well....of course there are these notes you're reading now, as well as a few videos on my YouTube channel.</p>"},{"location":"sidebar/custom-build-description.html#using-a-kit","title":"Using a kit","text":"<p>An important thing to note is that I used the FYSETC ERCF kit (6 gate version). So almost all of the hardware needed came from that kit (save for some M3 T-Nuts and some M3 screws, a length of 2020 extrusion for SturdyBunny and a spring for the Springy mod). So far this kit seems to be pretty nice.</p> <p>There are other kits available and of course you can self-source all of the pieces. Given all the little bits and pieces needed, I'd recommend a kit for most builders.</p>"},{"location":"sidebar/filament-cutters.html","title":"Filament Cutter options","text":"<p>You can do the original tip tuning step, or you could possibly skip that whole (time consuming and tricky) process and instead cut off the pesky tip rather than try to tune it.</p>"},{"location":"sidebar/filament-cutters.html#toolhead-cutter-options","title":"Toolhead cutter options","text":"<p>I am using a Sherpa mini extruder for my BBox printers and think these designs on Printables might be something I could adapt. They basically go between the Sherpa and whatever it was mounting to. </p> <p></p> <p>These designs I found look promising. It's always appreciated when people take the time to share with the community!</p>"},{"location":"sidebar/filament-cutters.html#filament-cutter-by-jb3d","title":"Filament cutter by JB3D","text":"<p>This one was shared on the Voron Discord server </p>"},{"location":"sidebar/filament-cutters.html#filament-cutter-by-the-printing-shark","title":"Filament cutter by The Printing Shark","text":"<p>This second one is a remix of the first and seems simpler and uses an Xacto blade rather than a box cutter blade. Looks to be a smaller design. </p>"},{"location":"sidebar/filament-cutters.html#another-option","title":"Another option","text":"<p>The most intriguing option at this time (for me) is the Filament Cutter for ERCF from KevinAkaSam. What distinguishes this design from the others is that the cutter is placed against the ERCF rather than being part of the toolhead. This would allow it to be used with most any existing printer/toolhead you already have.</p> <p></p> <p>This is undergoing lots of development these past few weeks. It's best to join his discord server and visit the ERCF Filament Cutter post to catch up on latest happenings.</p> <p>Update: I've decided to go with this cutter and have already built and insalled this onto my ERCF. I'll update this site soon with more info and hopefully pics</p>"},{"location":"sidebar/fysetc-erb.html","title":"Preparing the FYSETC ERB board","text":"<p>There is a Github repo for this board. It provides instructions on how to build and flash Klipper firmware onto the FYSETC ERB board.  You can find that repo here</p> <p>I chose the option that lets you build and flash directly from your Klipper host (usually a Raspberry Pi....but not for me as I use other devices for my printers).</p> <p>Run the following commands (line by line) on your Klipper host (usually a Raspberry Pi).</p> <pre><code>cd  ~/klipper\nmake clean\nmake menuconfig\n</code></pre> <p>Select the options as shown in this screenshot</p> <p></p> <p>Exit the menu config using the <code>ESC</code> key. Then use the following command to actually build the firmware.</p> <pre><code>make\n</code></pre> <p>After the firmware is built you will want to power up the FYSETC ERB and get into boot mode so you can flash this firmware onto it. Follow these steps to get into boot mode.</p> <ol> <li>Connect 24V to the ERB</li> <li>Connect USB-C cable to ERB and your Klipper device (usually Raspberry Pi)</li> <li>Push and hold the <code>BOOTSEL</code> button (keep this held down until step 6)</li> <li>Push and hold <code>RST</code> button for 0.5 seconds, then release</li> <li>Continue holding the <code>BOOTSEL</code> button for another 3 seconds, then release</li> <li>The ERB will have reset into boot mode and you can verify this using <code>lsusb</code></li> </ol> <p></p>"},{"location":"sidebar/happy-hare.html","title":"Setting up Happy Hare","text":"<p>Happy Hare is the software package that you will use with your new SturdyBunny/ERCF. It replaces the software described in the original ERCF v1.1 manual. </p> <p>Note: Happy Hare isn't just for ERCF, it can work with other MMU systems. But for our purposes we are using it to interface with the SturdyBunny/ERCF we just built</p> <p>TODO</p>"},{"location":"sidebar/happy-hare.html#just-some-misc-notes-while-im-working-on-this","title":"Just some misc notes while I'm working on this","text":""},{"location":"sidebar/happy-hare.html#basic-install-of-happy-hare","title":"Basic install of Happy Hare","text":"<p>Clone Happy Hare v2.2 from the Github repo</p> <pre><code>cd ~\ngit clone https://github.com/moggieuk/Happy-Hare.git\ncd Happy-Hare\n</code></pre> <p>The docs say there's a way to perform a kind of dry-run of the install without actually modifying your current installation. It will end up creating the files that a normal install would but it will place them into your <code>/tmp</code> folder so you can inspect them before doing a real install.</p> <pre><code>./install.sh -i -c /tmp -k /tmp\n</code></pre> <p>This let me inspect what it would do (look in the <code>mmu</code> subfolder it creates and view the files)</p> <p>Then I decided to actually install it:</p> <pre><code>cd ~/Happy-Hare\n./install.sh -i\n</code></pre> <p>Using the <code>-i</code> parameter so that the install script will interactively prompt you for various options. The first question you are asked is what type of MMU are you running. For this build I tried several of the options before determining the best one. The options I chose were \"ERCF v1.1. (all variations)\", \"ERCF v2.0\" and \"Other (Custom creation, ...)\".</p> <p>I intitially thought that \"ERCF v2.0\" might be the best option, since I'm using SturdyBunny, Thumper Blocks, Springy and Binky. But the problem is that if you choose \"ERCF v2.0\" some configuration values will be generated based on Happy Hare thinking you're using the 23.05mm wide Triple Decky filament blocks when we're actually using the 21.0mm Thumper Blocks. This ends up breaking the <code>MMU_CALIBRATE_SELECTOR</code> auto-calibration later on.</p> <p>I tried custom but that wasn't sufficient as well. It turns out that choosing \"ERCF v1.1. (all variations)\" worked the best as it will let you specify each mod you're using. When it asks you if you are using \"Triple-Decky\" just say no and it will end up using the correct 21.0mm width that Thumper Blocks and original SturdyBunny/ERCF uses.</p> <p>Here's what the install script looks like when I ran it and chose the correct options for my particular build.</p> <pre><code>donovan@kp:~/Happy-Hare$ ./install.sh -i\n\nKlipper config directory (/home/donovan/printer_data/config) found\nKlipper service found\nReading default configuration parameters...\n\nLet me see if I can help you with initial config (you will still have some manual config to perform)\n\nWhat type of MMU are you running?\n1) ERCF v1.1 (all variations)\n2) ERCF v2.0\n3) Tradrack v1.0\n4) Other (Custom creation, ...)\nMMU Type? (1-4)? 1\nSome popular upgrade options for ERCF v1.1 are supported. Let me ask you about them...\nAre you using the 'Springy' sprung servo selector cart (y/n)? y\nAre you using the improved 'Binky' encoder (y/n)? y\nAre you using the wider 'Triple-Decky' filament blocks (y/n)? n\n\n----------\nLet me see if I can help you with initial config (you will still have some manual config to perform)...\nAre you using the EASY-BRD or Fysetc Burrows ERB controller? (y/n)? y\nGreat, I can setup almost everything for you. Let's get started\n\n----------\nYou seem to have a RP2040-based controller serial port.\nAre you using the Fysetc Burrows ERB controller? (y/n)? y\n----------\nThis looks like your ERB controller serial port. Is that correct?\n/dev/serial/by-id/usb-Klipper_rp2040_E66888351B82A336-if00 (y/n)? y\n\nBoard Type: ERB\n\n----------\nTouch selector operation using TMC Stallguard? This allows for additional selector recovery steps but is difficult to tune\nEnable selector touch operation (not recommend if you are new to MMU / Happy Hare (y/n)? n\n\n----------\nHow many gates (selectors) do you have (eg 3, 6, 9, 12)?\nNumber of gates? 6\n\n----------\nDo you have a toolhead sensor you would like to use?\n(if reliable this provides the smoothest and most reliable loading and unloading operation)\nEnable toolhead sensor (y/n)? n\n\n----------\nWhich servo are you using?\n1) MG-90S\n2) Savox SH0255MG\nServo? (1-2)? 1\n\n----------\nClog detection? This uses the MMU encoder movement to detect clogs and can call your filament runout logic\nEnable clog detection (y/n)? y\n    Would you like MMU to automatically adjust clog detection length (recommended)?\n    Automatic (y/n)? y\n\n----------\nEndlessSpool? This uses filament runout detection to automate switching to new spool without interruption\nEnable EndlessSpool (y/n)? n\n\n----------\nFinally, would you like me to include all the MMU config files into your printer.cfg file\nAdd include? (y/n)? y\n    Would you like to include Mini 12864 menu configuration extension for MMU\n    Include menu (y/n)? n\n    Would you like to include legacy ERCF_ command set compatibility module\n    Include legacy ERCF command set (y/n)? y\n    Would you like to include the default pause/resume macros supplied with Happy Hare\n    Include client_macros.cfg (y/n)? n\n\nmmu_vendor: ERCF\nmmu_version: 1.1sb\nmmu_num_gates: 6\nservo_up_angle: 30\nservo_move_angle: 30\nservo_down_angle: 140\nenable_clog_detection: 2\nenable_endless_spool: 0\ngate_parking_distance: 23\n\n\n    vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n\n    NOTES:\n     What still needs to be done:\n     * Tweak motor speeds and current, especially if using non BOM motors\n     * Adjust motor direction with '!' on pin if necessary. No way to know here\n     * Move you extruder stepper configuration into mmu/base/mmu_hardware.cfg\n     * Adjust your config for loading and unloading preferences\n\n    Advanced:\n         * Tweak configurations like speed and distance in mmu/base/mmu_parameter.cfg\n\n    Good luck! MMU is complex to setup. Remember Discord is your friend..\n\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nCopying original printer.cfg file to /home/donovan/printer_data/config/printer-20231114_205612.cfg-old\nCopying configuration files into /home/donovan/printer_data/config/mmu directory...\nConfig directory /home/donovan/printer_data/config/mmu already exists - backing up old config files to /home/donovan/printer_data/config/mmu-20231114_205612\nInstalling configuration file mmu.cfg\nInstalling configuration file mmu_hardware.cfg\nInstalling configuration file mmu_parameters.cfg\nInstalling configuration file mmu_software.cfg\nSkipping copy of mmu_vars.cfg file because already exists\nLinking mmu extensions to Klipper...\nLinking mmu extension to Moonraker...\nAdding update manager to moonraker.conf\n[update_manager happy-hare] already exists in moonraker.conf - skipping install\n[mmu_server] already exists in moonraker.conf - skipping install\nKlipper not restarted automatically because you need to validate and complete config\n\nDone.  Enjoy ERCF (and thank you Ette for a wonderful design)...\n\n(\\_/)\n( *,*)\n(\")_(\") Happy Hare Ready\n\ndonovan@kp:~/Happy-Hare$\n</code></pre> <p>This should complete the basic install. You will want to restart the Klipper firmware (using Mainsail interface) before continuing on with calibration. After this install I restarted the Klipper firmware (using Mainsail) and then i performed the basic hardware config/tests found in the hardware configuration doc. </p>"},{"location":"sidebar/happy-hare.html#hardware-configurationtesting-of-our-ercf-for-use-with-happy-hare","title":"Hardware configuration/testing of our ERCF for use with Happy Hare","text":"<p>The basic hardware configuration steps are found in the hardware configuration doc.  I will summarize the steps that I followed with some clarification and/or pointers.</p> <p>TODO elaborate on this section.</p> <ul> <li>I checked that the endstop was working (use MainSail query endstops, manually trigger the switch, view that it is triggered with Mainsail, etc)</li> <li>Use <code>MMU_MOTORS_OFF</code> to ensure all motors off, move selector manually to middle, use <code>MMU_HOME</code> to test selector moves in the proper direction. Adjust config if needed.</li> <li>Check encoder via <code>MMU_ENCODER</code>, insert filament and push/pull so it moves the encoder wheel, re-issue <code>MMU_ENCODER</code> and value should always increase</li> </ul> <p>Since I had used a spare Nema17 for the gear motor I found that </p>"},{"location":"sidebar/happy-hare.html#basic-calibrationtesting-of-your-ercf-for-use-with-happy-hare","title":"Basic calibration/testing of your ERCF for use with Happy Hare","text":"<p>The calibration steps are described in the MMU Calibration Doc. I will summarize the steps that I followed with some clarification and/or pointers.</p>"},{"location":"sidebar/happy-hare.html#step-1-calibrate-selector-offsets","title":"Step 1. Calibrate selector offsets","text":"<p>Line up the selector against the first gate (Gate 0) so that you can pass filament from inlet side to outlet side. Using your fingers, rotate the selector pulley clockwise/counter-clockwise back and forth slightly, you'll see that there is a small range that you can move the selector as the filament is keeping it in place. Use the pulley to center the selector in the middle of this range. </p> <p>Pro Tip: Look down and see where the side of the selector lines up against a filament block hopefully its just a couple of millimeters away from a filament block edge. Then move back the selector back and forth until you figure out the range that it travels, then slide the selector's edge until it is in the middle of that range. Alternatively  look at the belt teeth by the selector edge, using the selector edge as visual marker. Move the selector back and forth and see how many teeth/valleys it travels within. This will tell you how much range is available, usually around two teeth/valleys. Halve this number to find the center and place the selector's edge at that point.</p> <pre><code>MMU_CALIBRATE_SELECTOR GATE=0\n</code></pre> <p>Repeat this process for gate 1 and changing the <code>GATE</code> parameter to <code>1</code></p> <pre><code>MMU_CALIBRATE_SELECTOR GATE=1\n</code></pre> <p>Repeat this for the rest of the gates remembering to change the <code>GATE</code> parameter each time.</p> <p>After you've done this for all of the gates you should now be able to select any gate using the <code>MMU_SELECT TOOL=XXX</code> command where <code>XXX</code> is replaced with the gate/tool number. For example the following will move the selector to gate 4.</p> <pre><code>MMU_SELECT TOOL=4\n</code></pre> <p>You can also use <code>MMU_HOME</code> command to select a gate/tool but this command will first home the selector before selecting the gate/tool.</p> <p>Note: If you execute the either <code>MMU_HOME</code> or <code>MMU_SELECT</code> command, the selector motor will remain engaged. Do not try to manually move the selector unless you turn off the motor via <code>MMU_MOTORS_OFF</code>.</p> <p>The \"end\" block (part <code>Filament_Blocks_End_Nobearing_V2A.stl</code>) has a built-in bypass hole. It doesn't have an ECAS collet like a real filament block but is usable as a quick and easy bypass. </p> <p>Filament End block with bypass hole </p> <p>If you wish to use this then you should also configure HappyHare about its offset now. Its the same procedure. Line up the selector to this bypass hole, feed the filament and center the selector. Then issue this command so it knows you're setting the position for the bypass.</p> <pre><code>MMU_CALIBRATE_SELECTOR BYPASS=1\n</code></pre>"},{"location":"sidebar/happy-hare.html#step-2-calibrate-your-gear-stepper","title":"Step 2. Calibrate your gear stepper","text":"<p>Issue the following in the console to home the selector and the move the selector to a convenient gate (gate 2 in this case)</p> <pre><code>MMU_HOME TOOL=2\n</code></pre> <p>Note: You could also just use <code>MMU_HOME</code> (without the specifying <code>TOOL</code>) in which case gate 0 will be selected.</p> <p>Have at least 400mm of filament handy. Either a length you've cut to size or on a spool holder that can freely feed this amount to the ERCF. Feed this by hand into the gate until the filament exits the ECAS04 collet on the selector and then pull back until it is flush with the collet.</p> <p>Attempt to move 100mm of filament</p> <pre><code>MMU_TEST_MOVE MOVE=100\n</code></pre> <p>Measure how much was actually moved and enter the following command with that value. That's it. Happy Hare now knows how to much to move the stepper motor to move a particular amount of filament.</p> <pre><code>MMU_CALIBRATE_GEAR MEASURED=99.5\n</code></pre>"},{"location":"sidebar/happy-hare.html#step-4-calibrate-encoder","title":"Step 4. Calibrate encoder","text":"<pre><code>MMU_CALIBRATE_ENCODER\n</code></pre>"},{"location":"sidebar/happy-hare.html#step-3-calibrate-bowden-length","title":"Step 3. Calibrate bowden length","text":"<p>The Happy Hardware documentation now wants you to calibrate the bowden length, and another simple macro is used for that. You just need to guesstimate the length of the bowden tube and subtract about 30mm from your guess. Let's say I measure around 350mm. I'd use this command.</p> <pre><code>MMU_CALIBRATE_BOWDEN BOWDEN_LENGTH=350\n</code></pre>"},{"location":"sidebar/happy-hare.html#but-wait","title":"But wait!","text":"<p>There are a few things I think you should really test/adjust before trying to calibrate your bowden length. This is important because this will be the first calibration step that will use the servo and push down on the tophats. So I really think it is important to ensure the servo arm is properly installed and if you're using the Springy mod, properly tensioned.</p> <p>Here is a short writeup on how I setup the servo arm</p> <p>Note: By default Happy Hare configures itself to use \"collision\" method. You can verify this by examining your <code>mmu_parameters.cfg</code> file and looking search for <code>extruder_homing_endstop</code>. While I eventually switched to using the \"touch\" (Stallguard) method I'm keeping my notes for when I used the \"collision\" method.</p> <p>But wait...there's more! Another important thing you must do is check your <code>mmu_hardware.cfg</code> and ensure the run current is appropriate for your gear stepper motor.</p> <pre><code># FILAMENT DRIVE GEAR STEPPER  ---------------------------------------------------------------------------------------------\n# Note that 'mmu_toolhead' endstop will automatically be added if a toolhead sensor is defined\n#\n# The default values are tested with the BOM NEMA14 motor. Please adapt these values to the motor you are using\n# Example : for NEMA17 motors, you'll usually use higher current\n#\n[tmc2209 stepper_mmu_gear]\nuart_pin: mmu:MMU_GEAR_UART\nuart_address: 0             # Comment out for ERB board\ninterpolate: True\nrun_current: 0.5            # NEMA14 motor\nhold_current: 0.1           # Recommend this is minimal to reduce power consumption (unless issues with TMC stallguard)\nsense_resistor: 0.110           # 0.15 for BTT TMC2226\nstealthchop_threshold: 0        # Spreadcycle has more torque and better at speed\n#\n# Uncomment two lines below if you have TMC and want the ability to use filament \"touch\" homing with gear stepper\n#diag_pin: ^mmu:MMU_GEAR_DIAG       # Set to MCU pin connected to TMC DIAG pin for gear stepper\n#driver_SGTHRS: 60          # 255 is most sensitive value, 0 is least sensitive\n</code></pre> <p>The <code>run_current</code> parameter is what you want to verify and possibly adjust. I'm using a Nema17 pancake motor, the default value you see here of <code>0.5</code> wasn't sufficient for my case. I initially had issues trying to calibrate my Bowden tube length because of this!!! It took me a bit of head scratching and inspecting the Happy Hare logs and Happy Hare source code to figure out that the process it was using to check for when the filament hit the extruder (\"collision\") wasn't working because the run current was too low.  I decided to use <code>0.650</code> and that worked for my particular setup.</p>"},{"location":"sidebar/happy-hare.html#what-mmu_calibrate_bowden-actually-does","title":"What <code>MMU_CALIBRATE_BOWDEN</code> actually does","text":"<p>Okay, if you've addressed those pre-requisites we're almost ready to run the <code>MMU_CALIBRATE_BOWDEN</code> command that I mentioned. But let me describe how it works.  In this example we'll say the bowden tube is about 530mm and we'll execute the following command.</p> <pre><code>MMU_CALIBRATE_BOWDEN BOWDEN_LENGTH=500 \n</code></pre> <p>Happy Hare will spin the gear motor until 500mm of filament have been extended into the bowden tube. Then it will repeatedly push out 3mm of filament, after each push it will see if the filament has moved or if it has collided with the extruder gears. When it detects no movement has occured after a push it concludes that it has collided with the extruder gears and stops trying to push any more filament. It does this three times.</p> <p>Note: During those 3mm steps that it performs, it reduces the run current of the stepper motor. This way when the filament collides with the extruder gears the gear stepper motor can skip steps or the BMG gears slip. I don't know exactly which of these two it is designed to do but I'm hoping the stepper motor skips rather than the BMG gears grinding the filament. </p> <p>Okay. Run that command with a guess of how long your filament is. When you do this watch the filament end through your reverse Bowden tube. Hopefully you'll see it push the filament through tube and stop before it hits the extruder and then it performs those incremental 3mm steps until it hits. If it doesn't stop before the extruder and just rams into it reduce the <code>BOWDEN_LENGTH</code> value. If it stops too soon and then performs those 3mm incremental steps but never reaches the extruder than increase the value of the <code>BOWDEN_LENGTH</code> parameter (or add the <code>HOMING_MAX=100</code> parameter as the default is 50 and 100 or more can be specified).</p> <p>Okay...if all goes well Happy Hare will perform 3 full tests (that you'll see being logged into the console) and then it will compute and save the actual length it detected and this part of your calibration is now done!</p> <p>One last thing </p> <p>You might want to consider tuning the reduced run current I mentioned earlier. The HappyHare docs say you can adjust the current when using \"collision\" method by adjusting the <code>extruder_homing_current</code> parameter in your <code>mmu_parameters.cfg</code> file. Here's what that section looks like:</p> <pre><code>extruder_homing_current: 40     # % gear_stepper current (10%-100%) to use when homing to extruder homing (100 to disable)\n</code></pre>"},{"location":"sidebar/happy-hare.html#the-mmulog-can-help-you-diagnose-things","title":"The <code>mmu.log</code> can help you diagnose things","text":"<p>Remember about that <code>run_current</code> setting? The reason I know about it is because I initially did this bowden calibration wrong by trying to work around a weird issue, not recognizing it for what it really was. Here's the story...</p> <p>The main issue I had trying to calibrate the bowden tube length was that Happy Hare was never pushing the filament to the extruder gears unless I overshot by a large amount the guesstimated distance from the ERCF to the extruder. So to make it \"work\" I simply gave it a large value until it hit the extruders and then it was able to detect that the filament had stopped and definitely \"collided\" with the extruder gears. I did not know how HappyHare was supposed to work and thought I just needed to do that. But I recognized later that this just didn't seem right. </p> <p>I re-read the Happy Hare documentation and it is supposed to advance up to <code>extruder_homing_max</code> (which is set to <code>50</code>) as it tries to collide with the extruder. This definitely wasn't happening for me. It would simply say \"sorry...not working\" (not really...but something short and simple was displayed...can't remember what exactly). I then examined the source code and traced it down to the code that performs this advancement. The code will log how many steps it will take and the outcome of each step. Ah...so the logfile should have clues! It is found at <code>~/printer_data/logs/mmu.log</code>. Sure enough, here is the relevant info it logged</p> <pre><code>11:28:57 Calibrating bowden length from reference Gate #0\n11:28:57 - DEBUG: Selecting tool T0 on gate #0...\n11:28:57 Tool T0 enabled\n11:28:57 - - TRACE: Setting MMU gear motor rotation distance ratio to 1.000000\n11:28:57 - - TRACE: Processing idle_timeout 'printing' event\n11:28:58 - DEBUG: Setting servo to down (filament drive) position at angle: 135\n11:29:00 - - TRACE: Initial load into encoder. Stepper: 'gear' moved 70.0mm, encoder measured 45.7mm (delta 24.3mm). Pos: @70.0, (45.7mm)\n11:29:00 - DEBUG: Loading bowden tube\n11:29:02 - - TRACE: Course loading move #1 into bowden. Stepper: 'gear' moved 254.3mm, encoder measured 253.2mm (delta 1.1mm). Pos: @300.0, (299.9mm)\n11:29:02 Finding extruder gear position (try #1 of 3)...\n11:29:02 - DEBUG: Homing to extruder gear, up to 50.0mm in 3.0mm steps\n11:29:02 Modifying MMU gear stepper run current to 27% for collision detection\n11:29:03 - - TRACE: Homing step #1. Stepper: 'gear' moved 3.0mm, encoder measured 0.0mm (delta 3.0mm). Pos: @303.0, (300.8mm)\n11:29:03 - DEBUG: Extruder entrance found after 3.0mm move (1 steps), encoder measured 0.0mm (delta 3.0mm)\n11:29:03 Restoring MMU gear stepper run current to 100% configured\n11:29:03 - DEBUG: Setting servo to up (filament released) position at angle: 50\n11:29:04 Failed to detect a reliable home position on this attempt\n</code></pre> <p>This line is crucial:</p> <pre><code>11:29:03 - - TRACE: Homing step #1. Stepper: 'gear' moved 3.0mm, encoder measured 0.0mm (delta 3.0mm). Pos: @303.0, (300.8mm)\n</code></pre> <p>It tells us that the very first step it executed to creep towards the extruder didn't work. It moved the gear 3mm but the filament didn't move at all. My guess is that my reduced run current was too low. And after finding the correct parameter to adjust and bumping it up, I could observe that Happy Hare was now able to creep the remaining distance using 3mm steps.</p> <p>Moral of the story: The log file along with some deductive reasoning can help. Even if you aren't able to decipher the log, you might be able to share it with someone (say over discord) who can help as it will give them more specific info about what might be happening</p>"},{"location":"sidebar/happy-hare.html#ensure-your-bowden-tube-is-locked-to-the-extruder","title":"Ensure your bowden tube is locked to the extruder","text":"<p>I'm using a Sherpa mini with a reverse bowden tube. The reverse bowden tube will pop out of a standard Sherpa mini because it isn't locked onto it with anything, just a hole with a slight friction fit.</p> <p>I ended up rebuilding it with this \"Sherpa Mini with Zero, ECAS, and Filament Sensor mods\"</p>"},{"location":"sidebar/happy-hare.html#setting-up-touch-stallguard-for-extruder","title":"Setting up \"Touch\" (Stallguard) for extruder","text":"<p>Note: While it looked really promising, I discovered that I would occassionally get fatal Klipper errors about TMC \"Undervoltage!\" errors when tring to use this technique. So I ended up switching back to collision, and then eventually I installed a \"toolhead sensor\" and that is really the best way to get your system to reliably work. I've kept the following info in case I get new hardware and want to retry \"touch\" homing. Or maybe I'm feeling adventurous and want to play with <code>stealthchop_threshold</code> values to work around the issue. Read the latest HappyHare documentation and you'll see moggieuk has some notes about this.</p> <p>Like I mentioned earlier, I initially used \"collision\" method but based on a post from Xon about \"touch\", I agreed with their description that \"touch\" is better as it doesn't lead to (as much) grinding of the filament. That is if you can make it work.</p> <p>Adjust <code>mmu_hardware.cfg</code> to enable stallguard (touch). Here is what that section looks like by default:</p> <pre><code># SELECTOR STEPPER  --------------------------------------------------------------------------------------------------------\n#\n[tmc2209 stepper_mmu_selector]\nuart_pin: mmu:MMU_SEL_UART\nuart_address: 1             # Comment out for ERB board\nrun_current: 0.4            # NEMA14 motor\nhold_current: 0.2           # Recommend this is small to reduce power consumption (unless issues with TMC stallguard)\ninterpolate: True\nsense_resistor: 0.110\nstealthchop_threshold: 100      # Stallguard \"touch\" movement (slower speeds) best done with stealthchop\n#\n# Uncomment two lines below if you have TMC and want to use selector \"touch\" movement and homing\n#diag_pin: ^mmu:MMU_SEL_DIAG        # Set to MCU pin connected to TMC DIAG pin for selector stepper\n#driver_SGTHRS: 75          # 255 is most sensitive value, 0 is least sensitive\n</code></pre> <p>Those last two lines need to be uncommented (remove the leading <code>#</code> character).  While testing this and playing with the sensitivity values I found that the default of 60 worked, while a value of 90 was too sensitive</p> <p>Docs say you can adjust the current when using \"collision\" method, not sure this setting also applies when using \"touch\" I'm gong to try it. For collision I use 45%</p> <pre><code>extruder_homing_current: 35     # % gear_stepper current (10%-100%) to use when homing to extruder homing (100 to disable)\n</code></pre> <p>Use the <code>MMU_CALIBRATE_BOWDEN</code> command as previously described after the above tests. It will not perform that incremental stepping to hit the extruder gears like it does with the \"collision\" method.</p>"},{"location":"sidebar/happy-hare.html#mmu_test_config","title":"<code>MMU_TEST_CONFIG</code>","text":"<p>This is a useful command that will let you change the values of numerous parameters \"on-the-fly\" so you don't have to edit a configuration file and restart Klipper to have your changes take effect. The only caveat is that once you have found values that work using this method you must remember to edit those configuration files to use these new values.</p> <p>Run the command without any parameters for a listing of what is available to tweak:</p> <pre><code>MMU_TEST_CONFIG\n</code></pre> <p>This is what I currently get back:</p> <pre><code>SPEEDS:\ngear_from_buffer_speed = 160.0\ngear_from_buffer_accel = 400.0\ngear_from_spool_speed = 60.0\ngear_from_spool_accel = 100.0\ngear_short_move_speed = 60.0\ngear_short_move_accel = 400.0\ngear_short_move_threshold = 60.0\ngear_homing_speed = 50.0\nextruder_homing_speed = 15.0\nextruder_load_speed = 15.0\nextruder_unload_speed = 15.0\nextruder_sync_load_speed = 16.0\nextruder_sync_unload_speed = 16.0\nextruder_accel = 400.0\nselector_move_speed = 200.0\nselector_homing_speed = 60.0\nselector_touch_speed = 80.0\nselector_touch_enable = 0\n\nTMC &amp; MOTOR SYNC CONTROL:\nsync_to_extruder = 1\nsync_form_tip = 1\nsync_gear_current = 50\nextruder_homing_current = 35\nextruder_form_tip_current = 100\n\nLOADING/UNLOADING:\nbowden_apply_correction = 0\nbowden_allowable_load_delta = 20\nbowden_pre_unload_test = 1\nextruder_force_homing = 1\nextruder_homing_endstop = mmu_gear_touch\nextruder_homing_max = 50.0\ntoolhead_sync_unload = 1\ntoolhead_homing_max = 40.0\ntoolhead_extruder_to_nozzle = 54.0\ntoolhead_sensor_to_nozzle = 62.0\ngcode_load_sequence = 0\ngcode_unload_sequence = 0\n\nOTHER:\nz_hop_height_error = 5.0\nz_hop_height_toolchange = 0.0\nz_hop_speed = 15.0\nenable_clog_detection = 2\nenable_endless_spool = 0\nenable_spoolman = 0\nslicer_tip_park_pos = 0.0\nforce_form_tip_standalone = 0\nstrict_filament_recovery = 0\nencoder_move_validation = 1\nauto_calibrate_gates = 0\nretry_tool_change_on_error = 0\nprint_start_detection = 1\nlog_level = 1\nlog_visual = 2\nlog_statistics = 1\npause_macro = PAUSE\nform_tip_macro = _MMU_FORM_TIP_STANDALONE\n\nCALIBRATION:\nmmu_calibration_bowden_length = 529.3\nmmu_calibration_clog_length = 8.3\n</code></pre> <p>So lets say I want to switch to another tip forming macro that I have like this one that got from Gennro. It is named <code>_MMU_FORM_TIP_GENNRO</code>.</p> <pre><code>MMU_TEST_CONFIG form_tip_macro=_MMU_FORM_TIP_GENNRO\n</code></pre> <p>It is important to ensure there are no spaces between parmeter name, the <code>=</code> character and the value.</p>"},{"location":"sidebar/misc.html","title":"Misc","text":"<p>Here is a forum thread where someone is documenting their ERCF build with photos.</p> <p>If you're using the original Encoder (say from a kit or self-sourced), it can be tricky to get good performance and a post on Voron discord server provided a link to some documentation on how to get best performance (like blackening the valleys of the BMG gear): https://discord.com/channels/460117602945990666/909743915475816458/1175864180243447828</p>"},{"location":"sidebar/printing.html","title":"Printing parts","text":"<p>The ERCF build manual provides a description on slicer settings. Basically the same as printing Voron parts</p> <ul> <li>0.2mm layer</li> <li>Forced 0.4mm extrusion width</li> <li>4 walls, 5 layers for top, 5 layers for bottom</li> <li>40% infill</li> <li>No need to add supports with your slicer</li> </ul>"},{"location":"sidebar/printing.html#two-tone-color-scheme","title":"Two-tone color scheme","text":"<p>The STL files can be printed with a primary and a secondary (accent) color. It looks pretty nice this way. I'm using red PolyMaker PolyLite ABS and Sunlu Blue ABS.</p> <p>The filename of an STL will have an <code>[a]</code> prefix to indicate if you should use the accent color for it.</p>"},{"location":"sidebar/printing.html#what-stl-files-do-we-need-to-print","title":"What STL files do we need to print?","text":"<p>The STL files for the printed parts will come from the projects/mods I mentioned earlier. You won't be using any STL files from the original ECRF project.</p> <ol> <li> <p>Start by downloading the original ERCF v1.1 manual. You will use this even though a lot of the parts are different; the new parts are still close enough to their original counterparts that you will find this manual to be helpful. </p> </li> <li> <p>Then you should clone the SturdyBunny project. Or download the zip and unzipping it somewhere to work with.</p> </li> <li> <p>Then do the same for Springy project.</p> </li> <li> <p>Do the same for Triple-Decky or Thumper Blocks depending on which one you decided to use.</p> </li> <li> <p>The Binky parts will be a little different. I haven't found a way to download a zip of just the files we need. Instead go to this page on Github. Then right click all of hte <code>.stl</code> files that are listed and download them individually to folder on you machine. You want all of the <code>.stl</code> files except <code>Encoder_Right_with_magnets.stl</code> as this part is only used for older ERCF filament blocks. It is not meant for use with Triple-Decky or Thumper Blocks.</p> </li> </ol> <p>Update: I have come across a great resource for keeping track of what STL files you will need to print. It is Matt's Unofficial ERCF v2 Printed Parts Tracker spreadsheet. Save a copy of this Google document and check/uncheck some of the boxes to match what you're building and it will tell you the number of parts to print for a specific STL file. However I will still itemize each and every part that I used for my build on this site page as it lets me keep the notes that I made along side the list.</p> <p>The rest of this document decribes in more detail the actual parts I've printed and anything noteworthy about them.</p>"},{"location":"sidebar/printing.html#sturdy-bunny-parts","title":"Sturdy Bunny parts","text":"<p>Because SturdyBunny is a fork, it also has the original parts in the repo. You want to ignore those. Intead you want to look at the \"Study_FeederV2 (development parts)\" folder that has subfolders for the STL files you will print as well as CAD (step) file that you can view to see how the assembly goes together.</p> <p></p> <p>In the following sections I will list the name of a folder in SturdyBunny and the STL files within that foler that you should print</p>"},{"location":"sidebar/printing.html#linear-axis","title":"Linear Axis","text":"<p>Print all of the files in the <code>Linear axis</code> folder except the <code>Idler_Block_V1A.stl</code> file as the Springy mod has a replacement for that part</p> <pre><code>/SturdyBunnyProject/Study_FeederV2 (development parts)/Stls/Linear axis\n  [a]_Drag_Chain_Anchor_Bottom.stl\n  [a]_Motor_Lock.stl\n  Selector_Motor_Support.stl\n</code></pre>"},{"location":"sidebar/printing.html#gear-box","title":"Gear Box","text":"<p>Print all of the files in the <code>Gear box</code> folder</p> <pre><code>/SturdyBunnyProject/Study_FeederV2 (development parts)/Stls/Gear box\n  [a]_Bearing_Spacer_x2.stl\n  [a]_Knob.stl\n  [a]_Logo_Plate.stl\n  [a]_M4_80T_Wheel.stl\n  [a]_Side_Latch_x2.stl\n  [a]_Top_Panel.stl\n  [a]Bottom_panel_V1B.stl\n  Gear_Box_Back_V2B.stl\n  Gear_Box_Front_V3C.stl\n\n</code></pre> <p>Note: OrcaSlicer warned about the <code>[a]_Side_Latch_x2.stl</code> part. It's okay, you can ignore that warning and print it without having to re-orient the part or enable supports. The part is a print-in-place type that has portion that swivels out.</p> <p></p> <p>I am using the FYSETC ERB board that came with my kit. This board is like the EASY BRD in that you will skip the part in the ERCF manual about using connectors that mount onto the motor arm. This means you'll want to print a motor arm part from the <code>EASY BRD Option</code> folder.</p> <p>Depending on the size of the Nema stepper you're using for the gearbox you will print one of the following parts. </p> <pre><code>/SturdyBunnyProject/Study_FeederV2 (development parts)/Stls/Gear box/EASY BRD Option\n  Motor_Arm_NEMA14_EASYBRD.stl\n  Motor_Arm_NEMA17_EASYBRD.stl\n</code></pre> <p>My FYSETC kit comes with a Nema14 which I'm not going to use. Instead I'll use a Nema17 from my parts bin so I chose to print <code>Motor_Arm_NEMA17_EASYBRD.stl</code></p>"},{"location":"sidebar/printing.html#tools","title":"Tools","text":"<p>There is a printed piece that is used as a gauge/jig to help you place the pulley on your Nema17 or Nema14 motor at the correct offset from the face of the motor. Choose one or the other from here:</p> <pre><code>SturdyBunnyProject/Study_FeederV2 (development parts)/Stls/Tools\n  Pulley_Tool_NEMA17.stl\n  Pulley_Tool_NEMA14.stl\n</code></pre> <p>Note:  There is also a <code>TOOL_FilamentBlock_BearingInstall_V2.stl</code> part in this folder that was intended for the original SturdyBunny filament blocks.  I found that it did not work with Thumper Blocks but it is possible that it might work with Triple-Decky</p>"},{"location":"sidebar/printing.html#selector","title":"Selector","text":"<p>You will ignore many of the parts in this <code>Selector</code> folder as Springy will provide different parts. However there are two parts that you will want to print from SturdyBunny:</p> <pre><code>/SturdyBunnyProject/Study_FeederV2 (development parts)/Stls/Selector\n  Belt_Tensionner.stl\n  Drag_Chain_Anchor.stl\n</code></pre>"},{"location":"sidebar/printing.html#filament-blocks","title":"Filament Blocks","text":"<p>You will ignore many of the parts in this <code>Filament blocks</code> folder as the Triple-Decky and Thumper Block mods will provide different parts. However there are a few parts that you will want to print from SturdyBunny:</p> <pre><code>/SturdyBunnyProject/Study_FeederV2 (development parts)/Stls/Filament blocks\n  Filament_Blocks_End_Foot_V1B.stl\n  Filament_Blocks_End_Nobearing_V2A.stl\n</code></pre> <p>Note: When you print <code>Filament_Blocks_End_Foot_V1B.stl</code> you should consider printing it in the accent color (if you're doing that) so that it matches the <code>[a]Bottom_panel_V1B.stl</code> part. You should also use your slicer's \"Auto\" orientation option, otherwise the default orientation has some bridging that may not turn out as clean as you'd like. Using the \"Auto\" orientation worked better for me.</p> <p></p>"},{"location":"sidebar/printing.html#supports","title":"Supports","text":"<p>I initially printed out some parts from this folder thinking they may be useful. It turns out I didn't need them or used something else. So in my opinion, you can ignore this folder.</p>"},{"location":"sidebar/printing.html#easy_brd","title":"EASY_BRD","text":"<p>My kit provided a FYSETC ERB controller board. It's footprint is pretty close to the Easy BRD board so the following part will let you mount it to the 2020 extrusion of the SturdyBunny. I wasn't able to use the <code>ESYBRD_COVER_V1A.stl</code> cover with my FYSETC ERB since it isn't exactly the same form factor as the Easy BRD.</p> <pre><code>/SturdyBunnyProject/Study_FeederV2 (development parts)/Stls/EASY_BRD\n  [a]ERCF_EASY_BRD_BRACKET_V1A.stl\n</code></pre> <p>Note: This is the one part out of everything I've printed that required supports </p>"},{"location":"sidebar/printing.html#triple-decky-parts-skip-this-if-using-thumper-blocks","title":"Triple-Decky parts (skip this if using Thumper Blocks)","text":"<p>For each of the following parts print out one for each gate. In my case my ERCF will have 6 gates (ports)</p> <pre><code>Triple-Decky/STL/Sturdy Bunny/Rev_C\n  [a]Triple_Decky_Latch_RevC6_0.stl\n\nTriple-Decky/STL/Sturdy Bunny/Rev_C/Rev_C7.0_3PS_only\n  [a]Triple_Decky_Tophat-integerated_3PS_C7_0.stl\n  Triple_Decky_Base_C7_0.stl\n  Triple_Decky_Filament_path_3PS_C7_0.stl\n</code></pre> <p>You can still use the revision C6.3 parts but I thought it might be better to use the latest filament block parts (C7.0 3PS). One important thing to keep in mind is the fitment of the \"base\" and \"filament-path\" parts. The upper \"filament-path\" part hinges/pivots against the \"base\" part. If this is not freely pivoting then there are additional versions of these parts that have increased clearance. They can be found in the <code>Clearance_options</code> subfolder:</p> <pre><code>Triple-Decky/STL/Sturdy Bunny/Rev_C/Rev_C7.0_3PS_only/Clearance_options\n  Triple_Decky_Base_C70_clrearance1.stl\n  Triple_Decky_Base_C70_clrearance2.stl\n  Triple_Decky_Filament_path_3PS_C70_clearance1.stl\n  Triple_Decky_Filament_path_3PS_C70_clearance2.stl\n</code></pre> <p>Be sure to check out the video at the bottom of the Triple-Decky README.md</p> <p>I've also put together a video that describes how I clean up these Triple-Decky parts and assemble them. This will also show you the type of smooth and feely pivoting action you should be going for</p> <p></p> <p>Next you need to print out one trap for each port (filament block). They are found in the <code>Traps</code> folder. I chose to use the \"V Shape\" variant:</p> <pre><code>Triple-Decky/STL/Sturdy Bunny/Rev_C/Traps\n  TD_Base_Trap_V-Shape_C56.stl\n</code></pre> <p>There is a setscrew variant. I think the difference is that the setscrew metallic threads impart greater friction against the filament when it is activated as brake. These reportedly work better for some folks compared to the \"v\" shape traps.</p> <p>My understanding is that these traps are simply holes that the filament will pass through. When a filament block is active (enaged by the selector) the path of the filament as it passes through a trap is straight and clear with minimal resistance. If a block is not active then the trap is lifted slightly and the filament is no longer straight through the trap hole and experiences resistance; this helps keep the filament from moving in/out of the block while the block is not active.</p> <p>If you have m3x2 or m3x3 setscrews then you might want to try that set screw variant instead:</p> <pre><code>Triple-Decky/STL/Sturdy Bunny/Rev_C/Traps\n  TD_Base_Trap_M3x3_C55.stl\n</code></pre> <p>The last part you'll need from Triple-Decky is the servo arm. My FYSETC uses an MG90S servo, so I printed out this part</p> <pre><code>Triple-Decky/STL/Sturdy Bunny/Rev_C/ Servo_arms_for_3PS\n  Servo_Arm_MG90S_for_3PS.stl\n</code></pre>"},{"location":"sidebar/printing.html#thumper-blocks-skip-this-if-using-triple-decky","title":"Thumper Blocks (skip this if using Triple-Decky)","text":"<p>I'm using the latest parts (<code>Rev_2</code>) that were released on 11/10/2023. For each of the following parts print out one for each gate. In my case my ERCF will have 6 gates (ports)</p> <pre><code>/Thumper-Blocks/STL/Rev_2\n  [a]_latch.stl\n  [a]_tophat_with_supports.stl\n  base.stl\n  filament_path.stl\n</code></pre> <p>Note: Thumper Blocks provides a copy of the Springy servo arm you will use, but I opted to use the servo arm file direct from the Springy project just in case it was updated. I describe the Springy parts in the next section</p> <p>I've also made a video about these filament blocks </p>"},{"location":"sidebar/printing.html#springy-parts","title":"Springy Parts","text":"<pre><code>ERCF-Springy\n  [a]_Springy_Selector_Cart.stl\n  Spring_Cap.stl\n  Springy_Idler_Block.stl\n  Springy_Selector_Door.stl\n</code></pre> <p>My FYSETC kit provides an MG90S servo, so I need to print out this part:</p> <pre><code>ERCF-Springy/MG90S_Servo_Option\n  Springy_MG90S_Servo_Mount.stl\n</code></pre> <p>If you're using Triple-Decky then skip the following (as you'll be printing the servo arm from Triple-Decky). I'm not using Triple-Decky, I'm using Thumper Blocks. So I'll be using this part for the servo arm:</p> <pre><code>ERCF-Springy/MG90S_Servo_Option\n  [a]_Servo_Arm_MG90S.stl\n</code></pre>"},{"location":"sidebar/printing.html#binky-parts","title":"Binky parts","text":"<p>As mentioned at the beginning of this section you'll need o download the Binky parts individually. You will print all of the parts found in that Binky stl folder except for the <code>Encoder_Right_with_magnets.stl</code> part as that is only used with older ERCF filament blocks; it will not work with Triple-Decky or Thumper Block.</p> <p></p>"},{"location":"sidebar/the-mods.html","title":"The various mods","text":"<p>For full details on the mods I've mentioned the best thing to do is to visit their Github project pages. Here are links to each of them:</p> <ul> <li>SturdyBunny</li> <li>Springy</li> <li>Triple-Decky</li> <li>Thumper Blocks</li> <li>Binky</li> <li>ERCF Filament Cutter</li> </ul> <p>For some of these mods I've taken some time to provide additional information and thought it would be useful to share here</p>"},{"location":"sidebar/the-mods.html#triple-decky","title":"Triple-Decky","text":"<p>This is a popular mod for the SturdyBunny. A lot of people have had great success with this mod that replaces the filament blocks found in SturdyBunny/ERCF. It has gone through several revisions and continues to improve with each one. Also the designer of Triple-Decky frequents the Voron <code>#ercf_questions</code> channel.</p> <p>Note: One thing to note about this mod, the filament blocks are 23.05mm wide compared to the original 21mm blocks in SturdyBunny. So this means if you are using a kit where the linear rods and the D-Shaft have already been cut to work with the 21mm blocks, that they may end up being shorter than you might feel comfortable with. If your kit was a 9 port/gate/channel version, you'll likely leave out a block leaving on 8.</p>"},{"location":"sidebar/the-mods.html#assembly-video-of-triple-decky-filament-blocks","title":"Assembly video of Triple-Decky filament blocks","text":"<p>Yes...I put together a video that describes how I clean up the printed parts and assemble them.</p> <p></p>"},{"location":"sidebar/the-mods.html#thumper-blocks","title":"Thumper Blocks","text":"<p>I just learned about a new filament blocks option today (11/10/2023) and asked about it in the following Voron discord server post. The designer of Thumper Blocks responded quickly and even pushed up a new revision (Rev_2) for me to try out.</p> <p>I've done some initial test prints and am really liking this design and think it might be an excellent option. I've already printed a bunch of Triple-Decky filament blocks but I think this Thumper Blocks design should be looked at as it has some really good design points:</p> <ul> <li>Base and Filament Path parts do not need supports</li> <li>My initial test prints of the Rev_1 pieces turned out great</li> <li>The \"brake\" uses a more readily available M4 nut </li> <li>The blocks are thinner so the original ERCF hardware (rods, etc) can be used</li> </ul> <p>Note: A major plus about this design is that if you're using pre-cut linear rods and D-shaft (say from a kit), you can keep the number of gates that the kit was designed for without having to possibly lose one if you had gone with the wider Triple-Decky blocks.</p> <p>More details about these Thumper Blocks differences can be found in the README.md</p> <p>I've also made a video about these filament blocks </p> <p>I'll update this section of the site after I get a chance to more fully evaluate this option. But so far I'm optimistic. It prints so much easier as it has no supports (except the tophat which is easy to remove) and the fitment of the parts that I'm getting from my printer seems to be just right. I like that I can use my existing hardware without having to lose a gate/port (as Triple-Decky is wider so you may lose a port....I do not know this for sure but I think that's the case).</p>"},{"location":"sidebar/the-mods.html#springy-selector-mod-video","title":"Springy Selector Mod Video","text":"<p>I took some video of my experience preparing and test fitting the Springy parts and found some time to edit/cut a video that I pushed up to YouTube</p> <p></p>"},{"location":"sidebar/tip-tuning.html","title":"Standlone Tip Tuning","text":"<p>I have spent a lot of time trying to understand and learn how to tune filament tips. My notes are pretty darn rough and scattered and many are even outdated.  Some of those notes will be found here and published early before being polished.</p> <p>So please excuse the messiness and be warned that some of these things are wrong</p> <p>Stuff at the bottom is more likely to be up to date and likely more valid</p>"},{"location":"sidebar/tip-tuning.html#use-the-happyhare-documentation","title":"Use the HappyHare documentation","text":"<p>This page of the Happy Hare documentation is loaded with useful info.</p> <p>I need to learn more about how to make this work as I had trouble getting the standlone tip tuning to work for me. I clearly need to read that document and simply start adjusting parameters as best as I can and then test and repeat that process until I get closer to forming the type of tip that I think will work for me.</p> <p>Note: I found an alternate tip forming macro that worked well enough until I found other ideas/approaches. This is worth checking out or at least recording here for posterity. The macro can be found here</p>"},{"location":"sidebar/tip-tuning.html#finally-found-some-more-info","title":"Finally found some more info!","text":"<p>See this post by 'moggieuk' on the Voron Discord server This in turn lead to a spreadsheet document with values for various hotends, the document has these tabs:</p> <ul> <li>Measuring Hot End Parameters</li> <li>Tip Tuning Parameters</li> </ul>"},{"location":"sidebar/tip-tuning.html#learning-about-happyhare-tip-tuning","title":"Learning about HappyHare tip tuning","text":"<p>As mentioned the documentation has some important info. In this section I will try to document what I am learning, hope to achieve and steps taken along the way.</p> <p>Switch to using HappyHare tip tuning macro instead of the <code>_MMU_FORM_TIP_GENNRO</code> macro I've been currentlly using.</p> <pre><code>MMU_TEST_CONFIG form_tip_macro=_MMU_FORM_TIP_STANDALONE\n</code></pre> <p>Open up <code>mmu_software.cfg</code> and you'll notice this section of the <code>_MMU_FORM_TIP_STANDALONE</code> macro that defines all of the parameters/variables:</p> <pre><code>########################################################################\n# Standalone Tip Forming (also helps with rapid tuning of Slicer values)\n########################################################################\n[gcode_macro _MMU_FORM_TIP_STANDALONE]\ndescription: Standalone macro that mimics SuperSlicer process\n\n# Unloading and Ramming values - Initial moves to form and shape tip\nvariable_unloading_speed_start: 80     # Fast here to seperate the filament from meltzone (Very intitial retract SS uses distance of E-15)\nvariable_unloading_speed: 20           # Too fast forms excessively long tip or hair. Slow is better here UNLOADING_SPEED_START/COOLING_MOVES seems a good start\nvariable_ramming_volume: 0             # (mm^3) SS default values = 2, 5, 9, 13, 18, 23, 27. Only Used to Simulate SS Ramming during standalone\nvariable_ss_ramming: 0                 # Set to 0 for standalone ramming (RAMMING_VOLUME), 1 to let the slicer do it (i.e. turn off for standalone)\n\n# Cooling Move Values - To cool the tip formed and separate from strings\nvariable_cooling_tube_position: 35     # Dragon ST: 35, Dragon HF: 30, Mosquito: 30, Revo: 35, Phaetus Rapido HF: 43;  Measured from Top of Heater Block to Top of Heatsink\nvariable_cooling_tube_length: 10       # Dragon ST: 15, Dragon HF: 10, Mosquito: 20, Revo: 10, Phaetus Rapido HF: 22; Measured from Nozzle to Top of Heater Block\nvariable_initial_cooling_speed: 10     # Slow to solidify tip and cool string if formed.\nvariable_final_cooling_speed: 50       # High speed break the string formed. Too fast = tip deformation during eject. Too Slow = long string/no seperation\nvariable_toolchange_temp: 0            # Used if you want to lower temp during toolchanges default 0\nvariable_cooling_moves: 4              # 2-4 is a good start\n\n# SkinnyDip values - To burn off VERY FINE hairs only (This is NOT for long tip reshaping)\nvariable_use_skinnydip: 1              # Tune this LAST, this is for removal of VERY FINE hairs only (Different than a long tip)\nvariable_skinnydip_distance: 30        # Start just under Cooling_tube_position and increase - Will depend on how much Ramming Volume is used\nvariable_dip_insertion_speed: 30       # Medium-Slow - Just long enough to melt the fine hairs. Too slow will pull up molten filament\nvariable_dip_extraction_speed: 70      # Around 2x Insertion speed, Prevents forming new hairs\nvariable_melt_zone_pause: 0            # Milliseconds - default 0\nvariable_cooling_zone_pause: 0         # Milliseconds - default 0 - If you need to adjust here its possible Dip Insertion too slow\nvariable_use_fast_skinnydip: 0         # Skip the toolhead temp change during skinnydip move - default 0\n\n# Final Eject - for standalone tuning only. Automatically set by `MMU_FORM_TIP` command\nvariable_final_eject: 0                # Default 0, enable during standalone tuning process to eject the filament\n\n# Park filament ready to eject\nvariable_parking_distance: 0           # Final filament parking position after final cooling move, 0 will leave filament where it naturally ends up\n\n</code></pre> <p>The following two variables seem pretty important:</p> <pre><code>variable_cooling_tube_position: 35     # Dragon ST: 35, Dragon HF: 30, Mosquito: 30, Revo: 35, Phaetus Rapido HF: 43;  Measured from Top of Heater Block to Top of Heatsink\nvariable_cooling_tube_length: 10       # Dragon ST: 15, Dragon HF: 10, Mosquito: 20, Revo: 10, Phaetus Rapido HF: 22; Measured from Nozzle to Top of Heater Block\n</code></pre> <p>The printer I'm using to test out my ERCF build is using a CHC V6 with a CHT nozzle. So not a volcano but regular form factor V6. So I can easily use some dimensions of a V6 found online rather than diassembling my toolhead to measure these values. After doing this I found that my CHC V6 is likely very similar to the Revo and the default values that were created by HappyHare are probably fine to use.</p> <p>So from a fresh power up I do this sequence</p> <pre><code>; Reset everything\nMMU_RESET CONFIRM=1\nMMU_HOME\nMMU_LOAD\n; make sure filament is inside hotend all the way and past the nozzle\n; Use Mainsail interface to extrude about 50mm\n</code></pre> <p>Here I had an issue, it wouldn't extrude. I finally tracked it to the gear stepper on the ERCF was skipping (stalling out) or simply not turning. I had enabled it to \"sync\" with extruder but it wasn't strong enough (reduced current) and so it was actually hampering the extrusion rather than helping with it.</p> <p>So disable that sync behavior</p> <pre><code>MMU_TEST_CONFIG sync_to_extruder=1\nMMU_TEST_CONFIG sync_gear_current=70\n</code></pre> <p>Retry the extrusion using Mainsail, everything works</p> <pre><code>; Now eject the filament, this should trigger standalone tip forming\nMMU_UNLOAD\n</code></pre> <p>Unfortunately the </p>"},{"location":"sidebar/tip-tuning.html#faster-way-to-check-tips","title":"Faster way to check tips","text":"<p>Initialize things just once</p> <pre><code>MMU_HOME\nMMU_CHECK_GATE\n</code></pre> <p>Feed filament, form tip, eject enough so you can pull out bowden tube and examine tip. Assumes tool 0 is the gate/tool that has the filament you're testing with</p> <pre><code># Feed filament to extruder and to hotend meltzone\nT0\n# Extrude a little so we know its completely in meltzone and a little past it (out of nozzle)\nM83\nG1 E10 F300\n# Form tip and eject tip out of extruder so you can pull bowden tube+filament and inspect\nMMU_EJECT EXTRUDER_ONLY=1\n</code></pre> <p>If tip is bad, then cut off. Whether you cut or not, make sure enough filament is pulled out of tube so that when you re-insert the tube you know the filament will be pushed against the extruder gears</p>"},{"location":"sidebar/tip-tuning.html#more-stuff","title":"More stuff","text":"<p>See here: https://discord.com/channels/460117602945990666/909743915475816458/1151726419420905542</p> <p>The idea is that to iterate on tuning the parameters you directly call the <code>MMU_FORM_TIP</code> macro and provide it parameters The parameter values persist until the next restart of Klipperer (or if you do an <code>MMU_RESET</code>).</p> <pre><code>MMU_FORM_TIP cooling_moves=3\n</code></pre> <pre><code>; Make logging to console verbose so we won't have to look at logfile\nMMU_TEST_CONFIG log_level=4\n; Use STANDALONE method instead of GENNRO\n; form_tip_macro = _MMU_FORM_TIP_GENNRO\nMMU_TEST_CONFIG form_tip_macro=_MMU_FORM_TIP_STANDALONE\n\n;\nMMU_EJECT FINAL_EJECT=1\n\n</code></pre> <pre><code>; Show current tip tuning parameters without running the macro\nMMU_FORM_TIP SHOW=1\n</code></pre> <pre><code>; Set one or more tip tuning parameters without running the macro\nMMU_FORM_TIP RUN=0 variable_parking_distance=50\nMMU_FORM_TIP RUN=0 variable_final_cooling_speed=70\nMMU_FORM_TIP RUN=0 variable_cooling_tube_position=35\nMMU_FORM_TIP RUN=0 cooling_moves=3\n\n</code></pre> <p>Getting these errors occassionally</p> <pre><code>TMC 'stepper_mmu_gear' reports error: GSTAT:      00000004 uv_cp=1(Undervoltage!)\n</code></pre>"},{"location":"sidebar/tip-tuning.html#recap","title":"Recap","text":"<p>In <code>mmu_parameters.cfg</code>. To prevent oozing when filament is loaded into extruder, adjust <code>toolhead_extruder_to_nozzle</code>. To deal with error that filament could not be ejected after tip tuning you can try to increase <code>toolhead_unload_safety_margin</code> from default 10 to something higher (say 20).</p> <pre><code>toolhead_extruder_to_nozzle: 50     # 54 was giving blobs when using STANDALONE tip forming method\ntoolhead_unload_safety_margin: 20   # 10: Distance added to the extruder unload movement to ensure filament is free of extruder. Must be less than 'gate_unload_buffer`\n</code></pre> <pre><code>sync_form_tip: 1                    # Synchronize during standalone tip formation (initial part of unload)\nforce_form_tip_standalone: 1        # 0 = Default smart behavior, 1 = Always do standalone tip forming (TURN SLICER OFF!)\nextruder_form_tip_current: 120      # % of extruder current (100%-150%) to use when forming tip (100 to disable)\n</code></pre> <p>Crucial parameters in <code>mmu_software.cfg</code> that are part of <code>_MMU_FORM_TIP_STANDALONE</code> macro</p> <pre><code>variable_cooling_tube_position: 40     # Spreadsheet calls this: \"Cooling Tube Retraction\".\nvariable_cooling_tube_length: 20       #\n</code></pre> <p><code>variable_cooling_tube_position</code> is how far back to retract the filament so that it is at the start point of the cooling region. I think</p> <p><code>variable_cooling_tube_length</code> is the length of the cooling region. The end point of the cooling region is at <code>variable_cooling_tube_position</code> + <code>variable_cooling_tube_length</code>.</p> <p>The actual tip tuning goes roughly like this:</p> <pre><code>    if ramming:\n        do some ramming\n    retract_ammount = 'cooling_tube_position' - ('cooling_tube_length'/2) \n    retract filament by retract_ammount millimeters\n    # filament should now be in middle of \"cooling tube\" or \"cooling region\".\n    # This is the 34mm we measured earlier\n</code></pre>"},{"location":"sidebar/tip-tuning.html#physical-examination","title":"Physical Examination","text":"<p>I separated the Sherpa Mini from the V6 hotend and its fan. I left the filament and bowden tube connected to the Sherpa Mini. I performed a <code>MMU_EJECT EXTRUDER_ONLY=1</code> to have the extruder pull the filament into its \"park\" location (right before the extruder gears). Then I performed <code>MMU_LOAD EXTRUDER_ONLY=1</code> so I could measure how far away from the base of the extruder the filament was pushed. This distance is 34mm (or sometimes 38mm) which seems about right as the base of the Sherpa Mini is about 16mm (more or less) away from the entry point of the BMG gears which combined yields 50mm and we've set <code>toolhead_extruder_to_nozzle</code> to the value of 50.</p> <p>With the filament extended into what is supposed to be the hotend meltzone (50mm), I then performed <code>MMU_EJECT EXTRUDER_ONLY=1</code> and observed that the filament would retract to about 27mm</p>"},{"location":"sidebar/tip-tuning.html#even-faster-way-to-inspect-tips","title":"Even faster way to inspect tips","text":"<p>I created some macros that allow me to load filament, extrude a bit so for sure we know nozzle is primed, then perform tip tuning and eject the filament only enough so that Bowden can be pulled out and tip examined. Then parameters can be modifed like this example:</p> <pre><code>MMU_FORM_TIP cooling_moves=3\n</code></pre> <p>Then a second macro to repeat the process.</p> <p>Create a <code>test_macros.cfg</code> and place it into the <code>mmu/optional</code> folder. Be sure to add an include line in your <code>printer.cfg</code> (something like this):</p> <pre><code>[include mmu/optional/test_macros.cfg]\n</code></pre> <p>Place the following into this new <code>test_macros.cfg</code></p> <pre><code>[gcode_macro FORM_TIP_AND_EJECT]\ndescription: Forms a tip and then ejects it out of extruder for inspection\ngcode:\n    # Feed filament to extruder and to hotend meltzone\n    T0\n    # Extrude a little so we know its completely in meltzone and a little past it (out of nozzle)\n    M83\n    G1 E25 F300\n    # Form tip and eject tip out of extruder so you can pull bowden tube+filament and inspect\n    MMU_EJECT EXTRUDER_ONLY=1\n\n[gcode_macro REFORM_TIP_AND_EJECT]\ndescription: Forms a tip and then ejects it out of extruder for inspection\ngcode:\n    # Feed filament to extruder and to hotend meltzone\n    MMU_LOAD EXTRUDER_ONLY=1\n    # Extrude a little so we know its completely in meltzone and a little past it (out of nozzle)\n    M83\n    G1 E25 F300\n    # Form tip and eject tip out of extruder so you can pull bowden tube+filament and inspect\n    MMU_EJECT EXTRUDER_ONLY=1\n</code></pre> <p>Use <code>FORM_TIP_AND_EJECT</code> to start (may need to do an <code>MMU_HOME</code> first if HappyHare tells you). You only use this macro this one time to start things off.</p> <p>Then pull out bowden tube and end of filament, inspect, tweak vars, make sure filament is  sufficiently pulled out of tube and then re-insert filament and tube back onto extruder. Then use <code>REFORM_TIP_AND_EJECT</code> to repeat the process as many times as you wish.</p> <p>ProTip: Use tab autocomplete in the console to avoid having to type out the full names of these macros</p> <p>Make sure you get familiar with the <code>MMU_FORM_TIP</code> macro so you can tweak the parameters easily during these test/inspect passes without having to restart Klipper (and HappyHare)</p> <p>Here are some examples</p> <pre><code>; Show current tip tuning parameters without running the macro\nMMU_FORM_TIP SHOW=1\n</code></pre> <pre><code>; Set one or more tip tuning parameters without running the macro\nMMU_FORM_TIP RUN=0 variable_parking_distance=50\nMMU_FORM_TIP RUN=0 variable_final_cooling_speed=70\nMMU_FORM_TIP RUN=0 variable_cooling_tube_position=35\nMMU_FORM_TIP RUN=0 cooling_moves=3\n\n</code></pre>"}]}